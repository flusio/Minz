<?php

namespace Minz;

/**
 * The Configuration class represents the configuration of the application.
 *
 * It must be loaded at the very beginning of any initialization of Minz-based
 * applications and scripts (e.g. `public/index.php`, `cli`, `tests/bootstrap.php`).
 * It’s done with the `load()` method. For instance, in `public/index.php`:
 *
 * ```php
 * $app_path = realpath(__DIR__ . '/..');
 * include $app_path . '/autoload.php';
 * \Minz\Configuration::load('development', $app_path);
 * ```
 *
 * The first argument is the environment name. Valid values are `development`,
 * `test` and `production`. It also can be set to `dotenv`, in which case Minz
 * will look for an `APP_ENVIRONMENT` environment variable (either with PHP
 * `getenv()` function or in a `.env` file). The second argument, `$app_path`,
 * must point to the root directory of your application.
 *
 * Configuration is loaded from a `$app_path/configuration/environment_$environment.php`
 * where `$app_path` and `$environment` are replaced by their corresponding
 * variables (e.g. `/path/to/myapp/configuration/environment_development.php`).
 * These files must return a PHP array and have access to the `$app_path`
 * variable. If a `.env` file exists at the root path, the files also have
 * access to a `$dotenv` variable. For instance, for an application named
 * `myapp`:
 *
 * ```php
 * return [
 *     'app_name' => 'myapp',
 *     'secret_key' => $dotenv->pop('APP_SECRET_KEY'),
 *     'url_options' => [
 *         'host' => $dotenv->pop('APP_HOST', 'localhost'),
 *     ],
 *     'data_path' => $dotenv->pop('APP_DATA_PATH', $app_path . '/data'),
 * ];
 * ```
 *
 * Configuration can then be accessed from anywhere in your application:
 *
 * ```php
 * echo 'Application name is: ' . \Minz\Configuration::$app_name;
 * echo 'Data path is: ' . \Minz\Configuration::$data_path;
 * echo 'Environment is: ' . \Minz\Configuration::$environment;
 * ```
 *
 * Available configuration variables are described below. Please note that some
 * are automatically generated, some must be declared, and the last are
 * optional.
 *
 * @see \Minz\Dotenv
 *
 * @author Marien Fressinaud <dev@marienfressinaud.fr>
 * @license http://www.gnu.org/licenses/agpl-3.0.en.html AGPL
 */
class Configuration
{
    private const VALID_ENVIRONMENTS = ['development', 'test', 'production'];

    private const VALID_DATABASE_TYPES = ['sqlite', 'pgsql'];

    private const VALID_MAILER_TYPES = ['mail', 'smtp', 'test'];

    /**
     * AUTOMATIC VARIABLES
     *
     * These variables are accessible in the configuration files, but you
     * really don’t want to overwrite their values. No, you don’t.
     */

    /**
     * @var string The environment in which the application run
     */
    public static $environment;

    /**
     * @var string The path to the root directory of the application
     */
    public static $app_path;

    /**
     * @var string The path to the configuration directory
     */
    public static $configuration_path;

    /**
     * @var string The path to the current configuration file
     */
    public static $configuration_filepath;

    /**
     * REQUIRED VARIABLES
     *
     * These variables *must* be declared in your configuration file. The
     * initialization will fail if they are not.
     */

    /**
     * @var string
     *     The name of the application. It must be identical to the application
     *     namespace (e.g. if your base namespace is `myapp\`, its value must
     *     be set to `myapp`).
     */
    public static $app_name;

    /**
     * @var string
     *     A cryptographically secret key generated by the administrator, it
     *     must be at least 64 chars long in production.
     */
    public static $secret_key;

    /**
     * @var array
     *     The web server information to build URLs. It’s an array where keys
     *     are:
     *     - host: the domain name serving your application (required)
     *     - port: the port of your server (default is set to `443` if protocol
     *       is https, else `80`)
     *     - path: the path to your application (default is `/`)
     *     - protocol: the protocol used by your server (default is `http`)
     */
    public static $url_options;

    /**
     * OPTIONAL VARIABLES
     *
     * Loading configuration will not fail if these variables aren’t declared
     * in your file. It doesn’t mean your application will work as expected
     * though.
     */

    /**
     * @var array
     *     Declare options specific to your application (default is an empty array)
     */
    public static $application;

    /**
     * @var string
     *     The path to the data directory (default is `$app_path/data`)
     */
    public static $data_path;

    /**
     * @var string
     *     The path to the SQL schema of your application (default is
     *     `$app_path/src/schema.sql`)
     */
    public static $schema_path;

    /**
     * @var string
     *     The path to a temporary directory (default is a random directory
     *     created under `sys_get_temp_dir()/$app_name`)
     */
    public static $tmp_path;

    /**
     * @var array
     *     The information to access your database. It’s an array where keys are:
     *     - dsn: the Data Source Name containing the info to connect to the
     *       database. Only `pgsql` and `sqlite` drivers are supported. A
     *       connection to a Postgres database requires that `host`, `port` and
     *       `dbname` are declared in the DSN. It is recommended to pass
     *       username and password separately. Username and password from the
     *       DSN have priority over the ones from the configuration.
     *     - username: the username to connect to the database (optional)
     *     - password: the password to connect to the database (optional)
     *     - options: options to pass to the \PDO constructor (optional)
     * @see https://www.php.net/manual/pdo.construct.php
     */
    public static $database;

    /**
     * @var array
     *     The information to send emails. It’s an array where keys are:
     *     - type: either `mail` (default), `smtp` or `test`
     *     - from: a valid email address (default is `root@localhost`)
     *     - debug: the level of verbosity of PHPMailer (default is `2` in
     *       development environment, `0` otherwise)
     *     - smtp: information to connect to a SMTP server (only used if type is `stmp`).
     *       It’s an array where keys are:
     *         - domain: the domain used in the Message-ID header (default is ``)
     *         - host: the SMTP server address (default is `localhost`)
     *         - port: the SMTP port (default is `25`)
     *         - auth: if SMTP authentication should be used (default is `false`)
     *         - auth_type: possible values are `CRAM-MD5`, `LOGIN`, `PLAIN`,
     *           `XOAUTH2` or `` (default)
     *         - username: the username to connect to the SMTP server (default is ``)
     *         - password: the password to connect to the SMTP server (default is ``)
     *         - secure: possible values are `ssl`, `tls` or `` (default)
     * @see \PHPMailer\PHPMailer\PHPMailer
     */
    public static $mailer;

    /**
     * @var boolean
     *     Specify if syslog must output \Minz\Log calls to the console
     *     (default is `false`)
     */
    public static $no_syslog_output;

    /**
     * Load the application configuration for a given environment.
     *
     * @param string $environment
     *     Can be set to development, production, test or dotenv. In the last
     *     case, a `APP_ENVIRONMENT` is searched either in the environment
     *     variables or in a `.env` file.
     * @param string $app_path
     *     The path to the root directory of the application.
     *
     * @throws \Minz\Errors\ConfigurationError
     *     Raised if the environment is not part of the valid environments, if
     *     the corresponding environment configuration file doesn't exist, if a
     *     required value is missing, or if a value doesn't match the required
     *     format.
     *
     * @return void
     */
    public static function load($environment, $app_path)
    {
        // If the app declares a .env file, we initialize a $dotenv variable
        // (it will be accessible in the configuration file then).
        $dotenv_path = $app_path . '/.env';
        if (file_exists($dotenv_path)) {
            $dotenv = new Dotenv($dotenv_path);
        }

        // If environment is set to dotenv, we look for an APP_ENVIRONMENT
        // environment variable to find the "real" value of the environment.
        if ($environment === 'dotenv') {
            if (isset($dotenv)) {
                $environment = $dotenv->pop('APP_ENVIRONMENT');
            } else {
                $environment = getenv('APP_ENVIRONMENT');
            }

            if (!$environment) {
                throw new Errors\ConfigurationError(
                    'You must declare an APP_ENVIRONMENT environment variable when using dotenv environment.'
                );
            }
        }

        if (!in_array($environment, self::VALID_ENVIRONMENTS)) {
            throw new Errors\ConfigurationError(
                "{$environment} is not a valid environment."
            );
        }

        // Load the configuration file and make sure that it exists. A missing
        // file would be problematic to load required variables :)
        $configuration_path = $app_path . '/configuration';
        $configuration_filename = "environment_{$environment}.php";
        $configuration_filepath = $configuration_path . '/' . $configuration_filename;
        if (!file_exists($configuration_filepath)) {
            throw new Errors\ConfigurationError(
                "configuration/{$configuration_filename} file cannot be found."
            );
        }

        // The consequence of including the configuration file this way is that
        // it has access to the variable declare above: that's what we want!
        $raw_configuration = include($configuration_filepath);

        // Initialize the automatic variables
        self::$environment = $environment;
        self::$app_path = $app_path;
        self::$configuration_path = $configuration_path;
        self::$configuration_filepath = $configuration_filepath;

        // Then, get the required variables from the configuration file
        self::$app_name = self::getRequired($raw_configuration, 'app_name');
        self::$secret_key = self::getSecretKey($raw_configuration, $environment);
        self::$url_options = self::getUrlOptions($raw_configuration);

        // And, finally, get the optional variables
        self::$application = self::getDefault($raw_configuration, 'application', []);
        self::$data_path = self::getDefault(
            $raw_configuration,
            'data_path',
            $app_path . '/data'
        );
        self::$schema_path = self::getDefault(
            $raw_configuration,
            'schema_path',
            $app_path . '/src/schema.sql'
        );
        self::$tmp_path = self::getDefault(
            $raw_configuration,
            'tmp_path',
            sys_get_temp_dir() . '/' . self::$app_name . '/' . bin2hex(random_bytes(10))
        );
        self::$database = self::getDatabase($raw_configuration);
        self::$mailer = self::getMailer($raw_configuration, $environment);
        self::$no_syslog_output = self::getDefault($raw_configuration, 'no_syslog_output', false);
    }

    /**
     * Return the value associated to the key of an array, or throw an error if
     * it doesn't exist.
     *
     * @param mixed[] $array
     * @param string $key
     *
     * @throws \Minz\Errors\ConfigurationError
     *     Raised if the given key is not in the array
     *
     * @return mixed
     */
    private static function getRequired($array, $key)
    {
        if (isset($array[$key])) {
            return $array[$key];
        } else {
            throw new Errors\ConfigurationError("{$key} configuration key is required");
        }
    }

    /**
     * Return the value associated to the key of an array, or a default one if
     * it doesn't exist.
     *
     * @param mixed[] $array
     * @param string $key
     * @param mixed $default
     *
     * @return mixed
     */
    private static function getDefault($array, $key, $default)
    {
        if (isset($array[$key])) {
            return $array[$key];
        } else {
            return $default;
        }
    }

    /**
     * Return the secret_key option.
     *
     * @param mixed[] $array
     * @param string $environment
     *
     * @throws \Minz\Errors\ConfigurationError
     *     Raised if the secret_key is missing, or if its length is less than
     *     64 chars in production.
     *
     * @return string
     */
    private static function getSecretKey($array, $environment)
    {
        $secret_key = self::getRequired($array, 'secret_key');

        if ($environment === 'production' && strlen($secret_key) < 64) {
            throw new Errors\ConfigurationError(
                'The secret_key must be at least 64 chars long and be cryptographically secure.'
            );
        }

        return $secret_key;
    }

    /**
     * Return the final url_options configuration.
     *
     * @param mixed[] $array
     *
     * @throws \Minz\Errors\ConfigurationError
     *     Raised if the url_options is missing, if it’s not an array, or if it
     *     doesn’t contain a host option.
     *
     * @return array
     */
    private static function getUrlOptions($array)
    {
        $url_options = self::getRequired($array, 'url_options');

        if (!is_array($url_options)) {
            throw new Errors\ConfigurationError(
                'URL options configuration must be an array, containing at least a host key.'
            );
        }

        if (!isset($url_options['host'])) {
            throw new Errors\ConfigurationError(
                'URL options configuration must contain at least a host key.'
            );
        }

        $default_url_options = [
            'path' => '/',
            'protocol' => 'http',
        ];
        $url_options = array_merge($default_url_options, $url_options);

        if (!isset($url_options['port'])) {
            $protocol = $url_options['protocol'];
            $url_options['port'] = $protocol === 'https' ? 443 : 80;
        }

        return $url_options;
    }

    /**
     * Return the final database configuration.
     *
     * @param mixed[] $array
     *
     * @throws \Minz\Errors\ConfigurationError
     *     Raised if the database option is not an array, if the dsn key is
     *     missing, or if the database type is invalid. Also if host, port or
     *     dbname are missing from the DSN if type is pgsql.
     *
     * @return array|null
     */
    private static function getDatabase($array)
    {
        $database = self::getDefault($array, 'database', null);
        if ($database === null) {
            return null;
        }

        if (!is_array($database)) {
            throw new Errors\ConfigurationError(
                'Database configuration must be an array, containing at least a dsn key.'
            );
        }

        if (!isset($database['dsn'])) {
            throw new Errors\ConfigurationError(
                'Database configuration must contain at least a dsn key.'
            );
        }

        $info_from_dsn = self::extractDsnInfo($database['dsn']);
        $default_db_info = [
            'username' => null,
            'password' => null,
            'options' => [],
        ];
        $database = array_merge($default_db_info, $database, $info_from_dsn);

        if (!in_array($database['type'], self::VALID_DATABASE_TYPES)) {
            throw new Errors\ConfigurationError(
                "{$database['type']} database is not supported."
            );
        }

        if ($database['type'] === 'pgsql') {
            if (!isset($database['host'])) {
                throw new Errors\ConfigurationError(
                    'pgsql connection requires a `host` key, check your dsn string.'
                );
            }

            if (!isset($database['port'])) {
                throw new Errors\ConfigurationError(
                    'pgsql connection requires a `port` key, check your dsn string.'
                );
            }

            if (!isset($database['dbname'])) {
                throw new Errors\ConfigurationError(
                    'pgsql connection requires a `dbname` key, check your dsn string.'
                );
            }
        }

        return $database;
    }

    /**
     * Split a DSN string and return the information as an array.
     *
     * @param string $dsn
     *
     * @return string[]
     */
    private static function extractDsnInfo($dsn)
    {
        $info = [];

        list($database_type, $dsn_rest) = explode(':', $dsn, 2);
        if ($database_type === 'sqlite') {
            $info['path'] = $dsn_rest;
        } elseif ($database_type === 'pgsql') {
            $dsn_parts = explode(';', $dsn_rest);
            foreach ($dsn_parts as $dsn_part) {
                list($part_key, $part_value) = explode('=', $dsn_part, 2);
                if ($part_key === 'user') {
                    $part_key = 'username';
                }
                $info[$part_key] = $part_value;
            }
        }

        $info['type'] = $database_type;

        return $info;
    }

    /**
     * Return the final mailer configuration.
     *
     * @param mixed[] $array
     * @param string $environment
     *
     * @throws \Minz\Errors\ConfigurationError
     *     Raised if the mailer option is not an array, or if the type key is
     *     invalid.
     *
     * @return array
     */
    private static function getMailer($array, $environment)
    {
        $mailer = self::getDefault($array, 'mailer', []);

        if (!is_array($mailer)) {
            throw new Errors\ConfigurationError(
                'Mailer configuration must be an array.'
            );
        }

        $default_mailer_options = [
            'type' => 'mail',
            'from' => 'root@localhost',
            'debug' => $environment === 'development' ? 2 : 0,
        ];
        $mailer = array_merge($default_mailer_options, $mailer);

        if (!in_array($mailer['type'], self::VALID_MAILER_TYPES)) {
            throw new Errors\ConfigurationError(
                "{$mailer['type']} is not a valid mailer type."
            );
        }

        if ($mailer['type'] === 'smtp') {
            $default_smtp_options = [
                'domain' => '', // the domain used in the Message-ID header
                'host' => 'localhost', // the SMTP server address
                'port' => 25,
                'auth' => false,
                'auth_type' => '', // 'CRAM-MD5', 'LOGIN', 'PLAIN', 'XOAUTH2' or ''
                'username' => '',
                'password' => '',
                'secure' => '', // '', 'ssl' or 'tls'
            ];
            if (!isset($mailer['smtp']) || !is_array($mailer['smtp'])) {
                $mailer['smtp'] = [];
            }
            $smtp_options = array_merge($default_smtp_options, $mailer['smtp']);
            $mailer['smtp'] = $smtp_options;
        }

        return $mailer;
    }
}
